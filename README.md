# 排序算法
## 作业要求
【排序算法：选择排序，归并排序，快速排序，希尔排序，基数排序】，对所有算法进行分析并实现，分析其在不同规模的输入下单机性能变化情况；

同时实现对于以下两种输入的排序:
①对数值的范围在[−10^100,10^100]的数组排序，此项任务只能使用C或C++完成。
②利用多线程实现大规模数据的分布式排序，输入超过100万为最低大规模要求。

## 基本排序算法实现及分析（基于C语言实现）
### 选择排序
选择排序的基本思想，每次都是从未排序数组中找出最小的一个加入到已排序数据中，故名选择排序。
外层循环进行排序的趟数是n，内存循环每次选择出最小的元素的时间复杂度是O(n)，因此整体的时间复杂度是
O(n^2)，空间复杂度是O(1)，且是一种不稳定的排序算法，因为存在元素的交换，因此相同元素的相对位置
可能发生改变。
### 归并排序
所谓二路归并排序,就是最初将长度为口的原始序列理解为由n个长度为1的按值有序的子序列组成,
并把这些子序列中相邻的子序列两两成对地进行合并，得到n/2个长度为2的按值有序子序列;
然后将这些子序列又两两成对地进行合并,得到n/4个长度为4的按值有序子序列;依次类推,
最后只剩一个长度为n的子序列,这个子序列就是原始序列经过二路归并排序后得到的结果。

归并的次数为logn次，每次进行归并的时间复杂度为O(n)，因此总体的时间复杂度为O(nlogn).
因为需要用到大小等于待排序数组个数的辅助空间，因此空间复杂度为O(n)

### 快速排序
快速排序方法的核心思想可以归纳为：在当前待排序的序列中任意选择一个元素作基准元素，
把小于等于分界元素的所有元素都移到分界元素的前边,把大于等于分界元素的所有元素都移到分界元素的后边,
这样，分界元素正好处在排序的最终位置上,并且把当前待排序的序列划分成前后两个子序列
(前一个子序列中所有元素都小于等于分界元素,后一个子序列中所有元素都大于等于分界元素)。
然后，分别对这两个子序列(若子序列的长度大于1的话)递归地进行上述过程，直到使得所有元素都到达整个排序后它们应处的最终位置上。

快速排序时，如果每次基准元素都位于中间的位置上，则需要进行的次数为O(logn)，而每次划分的时间复杂度
是O(n)，因此总体时间复杂度为O(nlogn)，但是当元素已经是排好序的时候，需要划分的次数变为n次，此时
的时间复杂度就是O(n^2)。

### 希尔排序
谢尔排序的核心思想是：首先确定一个元素间隔数 gap(也称增量）,然后将参加排序的序列按此间隔数从
第1个元素开始依次分成若干个子序列，即分别将所有位置相隔为gap的元素视为一个子序列，
在各个子序列中采用某种排序方法进行排序(这里采用冒泡排序);然后减小间隔数，并重新将整个序列按新的间隔数分成若干个子序列,
再分别对各个子序列进行排序，如此下去，直到间隔数 gap=1。

希尔排序时初始gap=n/2，结束时gap=1，外层循环的次数是logn，内层循环排序的时间复杂度为O(n)，因此总体
时间复杂度为O(nlogn)

### 基数排序
基数排序法的核心思想是：把参加排序的序列中的元素先按第1位(设最右边一位为第1位,其左边那一位为第2位，依此类推)
的值进行排序，然后再按第2位的值进行排序，最后按第d位的值进行排序。每一趟排序过程中若有元素的位值相同，
则它们之间仍然保留前一趟排序的先后次序。

算法要对序列进行d趟排序，每趟要把n个元素依次分配到各个分队，又把r个分队的元素再集中到总队，
每一趟排序花费的时间为O(r+n)。所以,基数排序算法总的时间开销为0(d(n+r))。


## 大数排序的分析及实现（基于C语言实现）
大数的数值范围比较大，只能用字符串表示，[-10^100,10^100]，需要的字符串位数是101位，再加上
一个负号需要占用一位，共是102位，所以用最大长度为102位的字符串来存储每个数字。

### 基于比较思路的分析及实现
基于比较思路的实现，原本是数字之间可以直接进行比较，现在则变为了字符串之间的比较。
可以字符串的比较分为三种情况：

1. 正数与正数的比较，先比较长度，长度大的值大，长度一样的，进行字符串比较
2. 负数与负数之间的比较，将其转化为正数与正数的比较，只不过结果要取反。
3. 一正一负的情况，自然是正数大于负数。

所以其基本的比较代码如下：
```c
int compare(char *a, char *b) {
    int alen = strlen(a);
    int blen = strlen(b);
    // 都为正，先比较长度，长度大的值大，长度一样的，进行字符串比较
    if (a[0] != '-' && b[0] != '-') {
        if (alen != blen) {
            return alen > blen ? 1 : -1;
        }
        return strcmp(a, b);
        // 都为负，先比较长度，长度小的值大，长度一样的，进行字符串比较，结果取反
    } else if (a[0] == '-' && b[0] == '-') {
        if (alen != blen) {
            return blen > alen ? 1 : -1;
        }
        return -strcmp(a, b);
        // 一正一负
    } else {
        if (a[0] == '-') {
            return -1;
        } else {
            return 1;
        }
    }
}
```

选择排序、归并排序、快速排序、希尔排序都可以基于这个比较思路进行编码。

### 基于计数思路的分析及实现
基数排序由于不是比较排序，因此上面的思路就需要调整。

#### 基数排序实现大整数排序的思路
与基数排序基本思路一致，需要将字符串的每位转换为数字，放入到对应的桶中即可。
将字符串的某一位转换为数字的代码如下：

```c
// 取字符串的倒数第i位字符，索引从1开始，并将字符串转换为数字
int charAtReversely(char *str, int i) {
    int n = strlen(str);
    if (i > n) {
        return 0;
    }
    //如果遇到负号，直接返回0
    if (str[n - i] == '-') {
        return 0;
    }
    return str[n - i] - 48;
}
```

### 测试数据
5  
1111111111111111111111111111  
1111111111111111111111111112  
2222222222222222333333333333  
123456789  
6666666666666666666666000001  

7  
1111111111111111111111111111  
1111111111111111111111111112  
-2222222222222222333333333333  
123456789  
6666666666666666666666000001  
892834297429  
-4567898765434567890  